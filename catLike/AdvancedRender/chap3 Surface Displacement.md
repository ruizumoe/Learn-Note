# 表面位移

在上一章节完成曲面细分以后，我们只是获得了平摊表面下的多个顶点，增加这些定义后的一个比较大的用处就是结合位移贴图或法线贴图更加表面细节，一般在LOD0的情况下使用。

由于曲面细分可以在特定情况下使用，因此可以保证在原始模型为低模的时候，也能在在近距离提高模型精度。

一般来说位移贴图都是在曲面细分阶段的域着色器上采样并使用。该阶段会根据新顶点的在原三角形中的重心获得相关数据，从而生成新的顶点信息，此时采样位移贴图作为定点的偏移量，就能得到一个更好的细节效果。

## 位移贴图和视差贴图的区别

### 位移贴图
位移贴图是在有足够多的顶点的情况下，让表面展现更丰富的外形轮廓，其本身不创造细节，而是将细节放大。在一些动态变形（雪地、脚印）、有机体平滑、需要完美轮廓的静态高细节的场景下，可以选用位移贴图。
优点：
1. 曲面细分+唯一贴图能创建真实的几何体，得到的轮廓细节遮挡等都是真实的
2. 可以实现动态lod
3. 在实现动态地形变形（脚印和雪地）目前是唯一主流

缺点：
1. 性能开销大且不稳定：大量增加三角形数量，对GPU的几何处理能力是巨大考验。过度细分会严重降低帧率。
2. 容易出现裂纹（Cracking）：如果相邻面片的细分因子不同，在边界处可能因为位移计算不一致而产生裂缝，需要精心处理。
3. 需要高质量位移贴图：垃圾进，垃圾出。如果位移贴图质量差或有接缝，效果会很难看。


### 视差贴图

视差贴图主要发生在像素着色器节点，其本身并没有生成新的顶点和高度信息，只是通过将贴图在平面上进行位移，从而模拟出高度位置。

其有三个阶段

1. 视差映射
    + 原理：根据视角方向和高度值，对纹理坐标进行简单的偏移。
    + 缺点：当表面深度变化很大或视角很陡时，会出现严重的失真和纹理拉伸，因为它没有考虑遮挡关系。
2. 陡峭视差映射
    + 原理：它将高度图数值理解为一系列深度层。从表面开始，沿着视角方向步进（Step），每次步进都检查当前层的高度和采样高度图的高度。
    + 过程：就像深度探测。一旦发现采样到的高度图数值（即表面实际高度）比当前步进的深度层更“浅”（即更靠近表面），就说明我们穿过了表面。
    + 缺点：由于是离散的步进，会有锯齿感，效果看起来像一层一层的阶梯。
3. 视差遮蔽映射（POM）
    + 原理：在陡峭视差映射的基础上，找到穿越表面的那一步和上一步。然后在这两步之间进行线性插值，从而得到一个非常精确的、平滑的交叉点。
    + 结果：这个插值后的点，就是我们最终应该采样的新纹理坐标。它不仅模拟了深度，还正确地模拟了遮挡关系（远处的点会被近处的点挡住）。
    + 效果：POM的效果非常出色，在多数情况下足以“以假乱真”，让人以为是真正的几何细节。性能开销是像素着色器中的多次纹理采样（通常是10-20次步进）。

详情请参考 [chap20 Parallax](../Rendering/chap20%20Parallax.md) 的光线步进章节内容。

优点：
1. 性能开销低
2. 效果出色
3. 无需硬件支持，只需要像素着色器支持即可

缺点：
1. 不改变轮廓，从侧方向看就会穿帮
2. 不产生自遮挡阴影，只能通过技巧去模拟阴影
3. 依赖视角和UV，在UV扭曲或视角极度倾斜的表面可能失效。


# 曲面细分+表面位移的视椎体剔除

细分效果虽然很出色，但其代价不菲，在视椎体外的物体不应该进行细分。

曲面细分是通过修改三角形的要细分因子实现的，如果将细分因子设置为0，原始三角形就会被抛弃。因此可以通过检查视椎体范围，修改非视椎体内的三角形面片的细分因子实现。


```glsl
// 检查是否在视椎体外
if (TriangleIsCulled(p0, p1, p2)) {
    f.edge[0] = f.edge[1] = f.edge[2] = f.inside = 0;
}
else {
    f.edge[0] = ...
}

```


## 视椎体剔除

视椎体是一个六面棱柱，如果一个物体在视椎体内部，那么其一定在视椎体的六个面上方，那么检查物体是否在六面体内部，就是分别检查点是否在面上方。

一个平面可以通过法向量（定义其局部向上方向）加上相对于世界原点的偏移量来定义。W 分量包含偏移量。

要判断点位于平面上方还是下方，可通过点积运算将该点向量投影至平面法向量。若结果为负值，则夹角大于 90°，表明该点位于平面下方。

相机的实际裁剪平面通过 unity_CameraWorldClipPlanes 数组提供, 其为一个6个索引地址的数组，分别对应左、右、底、顶、近和远平面。


```glsl
bool TriangleIsBelowClipPlane (float3 p0, float3 p1, float3 p2) {
	float4 plane = float4(1, 0, 0, 0);
	return
		dot(float4(p0, 1), plane) < 0 &&
		dot(float4(p1, 1), plane) < 0 &&
		dot(float4(p2, 1), plane) < 0;
}

```

## 有偏剔除

当原始三角形位于其视椎体外部时，会因为剔除不当出现孔洞，该问题的解决方案是在判断三角形是否位于裁剪平面下方时，将最大位移量纳入考量。可通过为 TriangleIsBelowClipPlane 添加偏置值实现：不再检查点积是否小于零，而是检查其是否低于此偏置值。

```glsl
bool TriangleIsBelowClipPlane (
	float3 p0, float3 p1, float3 p2, int planeIndex, float bias
) {
	float4 plane = unity_CameraWorldClipPlanes[planeIndex];
	return
		dot(float4(p0, 1), plane) < bias &&
		dot(float4(p1, 1), plane) < bias &&
		dot(float4(p2, 1), plane) < bias;
}

```

如果bias为正表示正向偏压，正向偏移会有效地将裁剪平面向上推，减小视锥体的大小。 但当三角形靠近视图边缘时，它们会过早地被裁剪掉。

负向偏移则产生相反的效果，因此位于视锥体外但仍靠近视锥体的三角形不会被裁剪。

在使用顶点位移时，我们必须采用负向偏移。